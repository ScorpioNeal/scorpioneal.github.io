<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="体系(点 - 线 - 面)">
<meta property="og:type" content="website">
<meta property="og:title" content="ScorpioNeal&#39;s Blog">
<meta property="og:url" content="http://blog.scions.cn/page/8/index.html">
<meta property="og:site_name" content="ScorpioNeal&#39;s Blog">
<meta property="og:description" content="体系(点 - 线 - 面)">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ScorpioNeal&#39;s Blog">
<meta name="twitter:description" content="体系(点 - 线 - 面)">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.scions.cn/page/8/">





  <title>ScorpioNeal's Blog</title>
  








  <link rel="stylesheet" href="/live2d/css/live2d.css">
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">
<div class="bg_content">
<canvas id="canvas"></canvas>
</div>
  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ScorpioNeal's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-todo">
          <a href="/todo/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            todo
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.scions.cn/posts/c09a1c52/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ScorpioNeal">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ScorpioNeal's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/c09a1c52/" itemprop="url">Android-EventBus2 & EventBus3对比</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-27T14:13:35+08:00">
                2019-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/c09a1c52/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/posts/c09a1c52/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用<code>method tracing</code>工具分析启动速度的时候，会发现<code>EventBus.getDefault().register</code>方法会耗时挺久，因此分析下<code>EventBus</code>源码，这里使用的是<code>EventBus2.4</code>. 之后，再来看下<code>EventBus3.0</code>究竟优化了什么地方，以及他们之间的性能比较。</p>
<p>为了便于理解，这里先把几个关键变量介绍一下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key is Event name</span></span><br><span class="line"><span class="comment"> * value is subscription</span></span><br><span class="line"><span class="comment"> * 也就是记录了某个事件上所有的注册信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录当前Object类里所有的注册信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录所有sticky的注册信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br></pre></td></tr></table></figure>

<p>其中，比较关键的一个类是<code>Subscription</code>. 这里的代码也比较少:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object subscriber; <span class="comment">//订阅者，也就是调用EventBus.getDefault().register(xx)里的xx</span></span><br><span class="line">    <span class="keyword">final</span> SubscriberMethod subscriberMethod; <span class="comment">//具体代码在下方</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Method method; <span class="comment">// 也就是每个类中所有onEventXXX()开头的方法, 赋值的地方在SubscriberMethodFinder.findSubscriberMethods里</span></span><br><span class="line">    <span class="keyword">final</span> ThreadMode threadMode;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; eventType; <span class="comment">// eventType是onEventXXX(ABC) 这里的ABC.getClass()</span></span><br><span class="line">    String methodString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面会详细分析这几个的区别</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  ThreadMode &#123;</span><br><span class="line">    PostThread,</span><br><span class="line">    MainThread,</span><br><span class="line">    BackgroundThread,</span><br><span class="line">    Async</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先对以上一些类先有个了解。 然后我们来具体看下<code>EventBus</code>.</p>
<p>我们知道, EventBus使用方式无外乎<code>register</code>, <code>unregister</code>, <code>post</code>, <code>postSticky</code>, <code>registeSticky</code>， 还有定义些<code>onEventXXX(EventType)</code>方法</p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>其中<code>register</code>, <code>registerSticky</code>都会走到这里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里是前文说的，找出一个类中所有onEvent开头的方法存在subscriberMethods里, 这里的findSubscriberMethods是使用反射来查找出来的</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());</span><br><span class="line">    <span class="keyword">for</span>(SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">        subscribe(subscriber, subscriberMethod, sticky, priority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    String key = subscriberClass.getName();</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (methodCache) &#123;</span><br><span class="line">        subscriberMethods = methodCache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; clazz = subscriberClass;</span><br><span class="line">    HashSet&lt;String&gt; eventTypesFound = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    StringBuilder methodKeyBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String name = clazz.getName();</span><br><span class="line">        <span class="keyword">if</span>(name.startsWith(<span class="string">"java."</span>) || name.startsWith(<span class="string">"javax."</span>) || name.startsWith(<span class="string">"android."</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method method : methods) &#123;</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            <span class="keyword">if</span>(methodName.startsWith(ON_EVENT_METHOD_NAME)) &#123;</span><br><span class="line">                <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                    <span class="keyword">if</span>(parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                        String modifierString = methodName.substring(ON_EVENT_METHOD_NAME.length());</span><br><span class="line">                        ThreadMode threadMode;</span><br><span class="line">                        <span class="keyword">if</span>(modifierString.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                            threadMode = ThreadMode.PostThread;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(modifierString.equals(<span class="string">"MainThread"</span>)) &#123;</span><br><span class="line">                            threadMode = ThreadMode.MainThread;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(modifierString.equals(<span class="string">"BackgroundThread"</span>)) &#123;</span><br><span class="line">                            threadMode = ThreadMode.BackgroundThread;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(modifierString.equals(<span class="string">"Async"</span>)) &#123;</span><br><span class="line">                            threadMode = ThreadMode.Async;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span>(skipMethodVerificationForClasses.containsKey(clazz)) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Illegal onEvent method, check for tyeps: "</span> + method);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                        methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">                        methodKeyBuilder.append(methodName);</span><br><span class="line">                        methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</span><br><span class="line">                        String methodKey = methodKeyBuilder.toString();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(eventTypesFound.add(methodKey)) &#123;</span><br><span class="line">                            subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, threadMode, eventType));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!skipMethodVerificationForClasses.containsKey(clazz)) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clazz = clazz.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass + <span class="string">" has no public methods called "</span></span><br><span class="line">                + ON_EVENT_METHOD_NAME);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (methodCache) &#123;</span><br><span class="line">            methodCache.put(key, subscriberMethods);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续来看下<code>subscribe</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充subscriptionsByEventType这个数据</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line"></span><br><span class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod, priority);</span><br><span class="line">    <span class="keyword">if</span>(subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                    + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == size || newSubscription.priority &gt; subscriptions.get(i).priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充typesBySubscriber这个数据</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span>(subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// registerSticky会去触发onEventXXX()方法的原因就是在这里</span></span><br><span class="line">    <span class="comment">// 这里的stickyEvents的赋值，是在postSticky方法中</span></span><br><span class="line">    <span class="keyword">if</span>(sticky) &#123;</span><br><span class="line">        Object stickyEvent;</span><br><span class="line">        <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">            stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码里可以知道， 这个方法目的就是填充<code>subscriptionsByEventType</code>和<code>typesBySubscriber</code>这两个数据。到这里<code>register</code>的工作就做完了。 然后我们来看下<code>post</code></p>
<h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><p>无论是<code>post</code>, 还是<code>postSticky</code>还是内部方法<code>postSingleEvent</code>,<code>postSingleEventForEventType</code>最终都会走到这里:</p>
<p>到这里，我们可以看到之前<code>ThreadMode</code>中定义的几种类型, 具体解释在注释里.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> PostThread: <span class="comment">// 在哪个线程post的，就在哪个线程invoke</span></span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MainThread:</span><br><span class="line">            <span class="keyword">if</span>(isMainThread) &#123;<span class="comment">// 如果post的是主线程，直接主线程invoke</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果post的是子线程，加入主线程队列中等待invoke</span></span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BackgroundThread:</span><br><span class="line">            <span class="keyword">if</span>(isMainThread) &#123; <span class="comment">//如果post是主线程，那么加入background线程队列里等待invoke</span></span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果post的是子线程，那么直接在当前线程invoke</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Async: <span class="comment">//不管post是在什么线程，均在asyncPoster线程的队列等待invoke</span></span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然最终都是调用到了上面那个方法，但是，他们来的渠道不一样. 对于<code>PostThread</code>最简单，直接在<code>EventBus</code>代码里过来的，但是另外三个，分别通过:</p>
<p>MainThread: &lt;- <code>HandlerPoster mainThreadPoster</code> 中调用的<code>eventBus.invokeSubscriber(pendingPost);</code><br>BackgroundThread &lt;- <code>BackgroundPoster backgroundPoster</code>中调用的<code>eventBus.invokeSubscriber(pendingPost);</code><br>Async &lt;- <code>AsyncPoster asyncPoster</code>中调用的<code>eventBus.invokeSubscriber(pendingPost);</code></p>
<p>不同的渠道过来，也可以看出，注册信息在多线程之间的传递是使用的被封装成了一个PendingPost的对象, 这个类实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingPost</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对象复用, 不用多次new操作?????这里不是很清楚</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span> ArrayList&lt;PendingPost&gt;();</span><br><span class="line"></span><br><span class="line">    Object event;</span><br><span class="line">    Subscription subscription;</span><br><span class="line">    PendingPost next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PendingPost</span><span class="params">(Object event, Subscription subscription)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.event = event;</span><br><span class="line">        <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> PendingPost <span class="title">obtainPendingPost</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = pendingPostPool.size();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                PendingPost pendingPost = pendingPostPool.remove(size - <span class="number">1</span>);</span><br><span class="line">                pendingPost.event = event;</span><br><span class="line">                pendingPost.subscription = subscription;</span><br><span class="line">                pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> pendingPost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PendingPost(event, subscription);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releasePendingPost</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">        pendingPost.event = <span class="keyword">null</span>;</span><br><span class="line">        pendingPost.subscription = <span class="keyword">null</span>;</span><br><span class="line">        pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">            <span class="comment">// TODO 这里不是很清楚</span></span><br><span class="line">            <span class="comment">// Don't let the pool grow indefinitely</span></span><br><span class="line">            <span class="keyword">if</span> (pendingPostPool.size() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                pendingPostPool.add(pendingPost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存了<code>Subscription</code>信息以及下一个<code>PendingPost</code>对象. 具体来看下这三个渠道的代码，如何把<code>PendingPost</code>发过来的</p>
<h3 id="HandlerPoster"><a href="#HandlerPoster" class="headerlink" title="HandlerPoster"></a>HandlerPoster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从构造函数可以知道，这里的<code>Handler</code>是<code>主线程的handler</code>, 维护了一个<code>PendingPost</code>的队列<code>PendingPostQueue</code>, 链表实现的队列。出列从head处，入列从tail入，代码比较简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingPostQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PendingPost head;</span><br><span class="line">    <span class="keyword">private</span> PendingPost tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"null cannot be enqueued"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail.next = pendingPost;</span><br><span class="line">            tail = pendingPost;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = tail = pendingPost;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Head present, but no tail"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> PendingPost <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = head;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tail = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pendingPost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> PendingPost <span class="title">poll</span><span class="params">(<span class="keyword">int</span> maxMillisToWait)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            wait(maxMillisToWait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HandlerPoster</code>每次取队列中的<code>head</code>数据，调用<code>eventBus.invokeSubscriber(pendingPost)</code>. 使用<code>Handler</code>机制从而实现始终保证主线程调用</p>
<h3 id="BackgroundPoster"><a href="#BackgroundPoster" class="headerlink" title="BackgroundPoster"></a>BackgroundPoster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executorRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>HandlerPoster</code>类似，循环取队列头元素，执行<code>eventBus.invokeSubscriber</code>, 只不过调用的线程为<code>BackgroundThread</code>线程</p>
<h3 id="AsyncPoster"><a href="#AsyncPoster" class="headerlink" title="AsyncPoster"></a>AsyncPoster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>BackgroundPoster</code>类似，都是通过<code>EventBus</code>里的<code>ExecutorService</code>启动一个线程，在线程里循环取<code>queue</code>中的<code>PendingPost</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    queue.enqueue(pendingPost);</span><br><span class="line">    eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的分析，可以知道，<code>EventBus 2</code>实现的原理主要是通过反射机制，把注册的类和注册的方法全部存到内存里，然后<code>postEvent</code>时候，根据内存信息查找特定的类里的特定的方法来处理Event事件。<br>因为反射本身性能很差，每次<code>register</code>的时候，都会把类中所有方法遍历一遍，找<code>onEventXXX()</code>方法，这里性能比较差。所以才会在<code>method tracing</code>中看到每次<code>register</code>相对都会很耗时。 </p>
<p>现在EventBus3已经出来了， 会不会有改进呢？ 我还没时间分析，具体可以参考下:</p>
<p><a href="https://juejin.im/entry/5948b9bc61ff4b006c047a0d" target="_blank" rel="noopener">https://juejin.im/entry/5948b9bc61ff4b006c047a0d</a></p>
<p>大致意思就是裸的EventBus3因为使用了运行时注解，所以效率还没2高，但是你可以加些注解，这些是编译时注解，在编译期就生成了EventBus2中register里最耗时的那些反射找方法的地方. 具体代码，留待分析 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.scions.cn/posts/c8244c97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ScorpioNeal">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ScorpioNeal's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/c8244c97/" itemprop="url">Android-SharedPreference原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-26T19:59:08+08:00">
                2019-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/c8244c97/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/posts/c8244c97/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用method tracing工具时，发现SharedPreference在初次使用的时候，占用的时间比较长。 因此，这里研究下SharedPreference源码， 了解下是什么消耗了的时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    SharedPreferences.java</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SharedPreferences</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSharedPreferenceChangeListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onSharedPreferenceChanged</span><span class="params">(SharedPreferences sharedPreferences, String key)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">        <span class="function">Editor <span class="title">putString</span><span class="params">(String key, @Nullable String value)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Editor <span class="title">putStringSet</span><span class="params">(String key, @Nullable Set&lt;String&gt; values)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Editor <span class="title">putInt</span><span class="params">(String key, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Editor <span class="title">putLong</span><span class="params">(String key, <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Editor <span class="title">putFloat</span><span class="params">(String key, <span class="keyword">float</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Editor <span class="title">putBoolean</span><span class="params">(String key, <span class="keyword">boolean</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Editor <span class="title">remove</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Editor <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">commit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, ?&gt; getAll();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getString</span><span class="params">(String key, @Nullable String defValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">getStringSet</span><span class="params">(String key, @Nullable Set&lt;String&gt; defValues)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(String key, <span class="keyword">int</span> defValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLong</span><span class="params">(String key, <span class="keyword">long</span> defValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(String key, <span class="keyword">float</span> defValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key, <span class="keyword">boolean</span> defValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Editor <span class="title">edit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerOnSharedPreferenceChangeListener</span><span class="params">(OnSharedPreferenceChangeListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterOnSharedPreferenceChangeListener</span><span class="params">(OnSharedPreferenceChangeListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SharedPreference和Editor都只是一个接口, Editor是SharedPreferences接口里的接口, 具体实现类在SharedPreferenceImpl.java里</p>
<p>这里，我们简化下代码， 不去分析OnSharedPreferenceChangeListener相关的东西， 因为用的比较少，而且不影响主要源码逻辑。</p>
<p>先看下，这里有三把锁</p>
<p><code>SharedPreferenceImpl.mLock</code>, <code>EditorImpl.mLock</code>, <code>mWritingToDiskLock</code></p>
<p>先看<code>mLock</code></p>
<h2 id="SharedPreferenceImpl-mLock"><a href="#SharedPreferenceImpl-mLock" class="headerlink" title="SharedPreferenceImpl.mLock"></a>SharedPreferenceImpl.mLock</h2><p>最开始是<code>startLoadFromDisk()</code>这里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startLoadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mLoaded = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"SharedPreferencesImpl-load"</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                loadFromDisk();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是一个标志位mLoaded, 表示是否已经把disk里的xml文件加载进来了</p>
<p>结合loadFromDisk()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLoaded) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">null</span>;</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                str = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(mFile), <span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line">                map = (Map&lt;String, Object&gt;) XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Cannot read "</span> + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        thrown = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// It's important that we always signal waiters, even if we'll make</span></span><br><span class="line">        <span class="comment">// them fail with an exception. The try-finally is pretty wide, but</span></span><br><span class="line">        <span class="comment">// better safe than sorry.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (thrown == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mMap = map;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// In case of a thrown exception, we retain the old map. That allows</span></span><br><span class="line">            <span class="comment">// any open editors to commit and store updates.</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以知道，这里只是把xml文件，映射到map里. 最后的finally里, mLock会notifyAll. 我们看下哪里调用了mLock.wait方法</p>
<p>阅读代码，可以知道，所有的getString(String , defValue), getXXX()等方法都会被同步锁mLock保护起来， 而且在实际获取值的时候，都会调用awaitLoadedLocked()</p>
<p>也就是说， 在调用getXXX()方法时，必须保证xml文件已经加载进了内存。不然就会阻塞等待加载完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String key, @Nullable String defValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v = (String)mMap.get(key);</span><br><span class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="comment">// Raise an explicit StrictMode onReadFromDisk for this</span></span><br><span class="line">        <span class="comment">// thread, since the real read will be in a different</span></span><br><span class="line">        <span class="comment">// thread and otherwise ignored by StrictMode.</span></span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> remove the need to call awaitLoadedLocked() when</span></span><br><span class="line">    <span class="comment">// requesting an editor.  will require some work on the</span></span><br><span class="line">    <span class="comment">// Editor, but then we should be able to do:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      context.getSharedPreferences(..).edit().putString(..).apply()</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// ... all without blocking.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EditorImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EditorImp-mLock"><a href="#EditorImp-mLock" class="headerlink" title="EditorImp.mLock"></a>EditorImp.mLock</h2><p>还有一些使用<code>mLock</code>的地方，我们等下在看。 先看下<code>mEditorLock</code></p>
<p>主要是在EditorImpl这个内部类里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">putString</span><span class="params">(String key, @Nullable String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">            mModified.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用Editor把数据写入mModified这个内存里，都是被mEditorLock保护着.</p>
<p>还有一个地方就是Editor里的apply(), commit()方法里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体来看下<code>commmitToMemory()</code>这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true if any changes were made</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MemoryCommitResult <span class="title">commitToMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> memoryStateGeneration;</span><br><span class="line">    Map&lt;String, Object&gt; mapToWriteToDisk;</span><br><span class="line">    <span class="comment">// 读xml文件加的锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (SharedPreferencesImpl.<span class="keyword">this</span>.mLock) &#123;</span><br><span class="line">        <span class="comment">// We optimistically don't make a deep copy until</span></span><br><span class="line">        <span class="comment">// a memory commit comes in when we're already</span></span><br><span class="line">        <span class="comment">// writing to disk.</span></span><br><span class="line">        <span class="keyword">if</span> (mDiskWritesInFlight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// We can't modify our mMap as a currently</span></span><br><span class="line">            <span class="comment">// in-flight write owns it.  Clone it before</span></span><br><span class="line">            <span class="comment">// modifying it.</span></span><br><span class="line">            <span class="comment">// noinspection unchecked</span></span><br><span class="line">            mMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(mMap);</span><br><span class="line">        &#125;</span><br><span class="line">        mapToWriteToDisk = mMap;</span><br><span class="line">        mDiskWritesInFlight++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写mModified时加的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> changesMade = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mClear) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mapToWriteToDisk.isEmpty()) &#123;</span><br><span class="line">                    changesMade = <span class="keyword">true</span>;</span><br><span class="line">                    mapToWriteToDisk.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                mClear = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</span><br><span class="line">                String k = e.getKey();</span><br><span class="line">                Object v = e.getValue();</span><br><span class="line">                <span class="comment">// "this" is the magic value for a removal mutation. In addition,</span></span><br><span class="line">                <span class="comment">// setting a value to "null" for a given key is specified to be</span></span><br><span class="line">                <span class="comment">// equivalent to calling remove on that key.</span></span><br><span class="line">                <span class="keyword">if</span> (v == <span class="keyword">this</span> || v == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mapToWriteToDisk.remove(k);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">                        Object existingValue = mapToWriteToDisk.get(k);</span><br><span class="line">                        <span class="keyword">if</span> (existingValue != <span class="keyword">null</span> &amp;&amp; existingValue.equals(v)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mapToWriteToDisk.put(k, v);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                changesMade = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mModified.clear();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (changesMade) &#123;</span><br><span class="line">                mCurrentMemoryStateGeneration++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            memoryStateGeneration = mCurrentMemoryStateGeneration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MemoryCommitResult(memoryStateGeneration,</span><br><span class="line">            mapToWriteToDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把mModified对象里的内容写入mapToWriteToDisk.</p>
<p>因此在前文中写入mModified时加了mEditorLock锁，因此这里先读取mModified时也需要加锁. 也就是说 mModified这把锁， 保护的是读写mModified这个对象</p>
<p>回过来继续看下这个commitToMemory方法调用的地方， 也就是<code>commit</code>和<code>apply</code>这两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(</span><br><span class="line">        mcr, <span class="keyword">null</span> <span class="comment">/* sync write on this thread okay */</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的applay会阻塞在<code>writtenToDiskLatch</code>这里，等待CountDownLatch倒计时结束后执行后文的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br></pre></td></tr></table></figure>

<p>而commit则直接执行enqueueDiskWrite方法。 </p>
<p>也证实了，commit在写到内存后直接就写入文件，而apply写入内存后，异步写入文件. 多并发的提交commit时，需等待正在处理的commit数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而apply只是原子更新到内存，后调用apply函数会直接覆盖前面内存数据，从一定程度上提高很多效率。</p>
<p>最后来看下mWritingToDiskLock</p>
<h2 id="mWritingToDiskLock"><a href="#mWritingToDiskLock" class="headerlink" title="mWritingToDiskLock"></a>mWritingToDiskLock</h2><p>也就是内存写入文件的地方, 防止多个线程操作文件，所以加把锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueDiskWrite</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> Runnable postWriteRunnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Typical #commit() path with fewer allocations, doing a write on</span></span><br><span class="line">    <span class="comment">// the current thread.</span></span><br><span class="line">    <span class="keyword">if</span> (isFromSyncCommit) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> wasEmpty = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            wasEmpty = mDiskWritesInFlight == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wasEmpty) &#123;</span><br><span class="line">            <span class="comment">// 同步方式</span></span><br><span class="line">            writeToDiskRunnable.run();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异步方式</span></span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过前文分析，SharedPreference代码里使用了大量的同步机制。<br>因此，使用不恰当，很容易出现耗时甚至ANR:</p>
<p>1.第一次读取时，造成主线程阻塞(文件过大，主线程等待时间过长)，引起ANR<br>2.文件太大，加载到内存中一直存在，占用大量内存<br>3.直接在主线程进行commit操作，造成阻塞，引发ANR<br>4.多次apply，造成锁竞争，浪费系统资源<br>5.Sp文件过大，每次更新都更新整个文件</p>
<p>优化建议:<br>1.对Sp进行合适的拆分<br>2.在合适的时机进行异步初始化<br>3.批量修改一次提交<br>4.在主线程谨慎使用commit</p>
<p>SharedPreferences每次写入时是增量写入吗？</p>
<pre><code>答：不是，每次都是重新写入，说一下那个mBackupFile，SharedPreferences在写入时会先把之前的xml文件改成名成一个备份文件，然后再将要写入的数据写到一个新的文件中，如果这个过程执行成功的话，就会把备份文件删除。由此可见每次即使只是添加一个键值对，也会重新写入整个文件的数据，这也说明SharedPreferences只适合保存少量数据，文件太大会有性能问题。SharedPreferences每次写入都是整个文件重新写入，不是增量写入。</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.scions.cn/posts/a578e2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ScorpioNeal">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ScorpioNeal's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/a578e2/" itemprop="url">Android Activity栈和启动模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-26T10:46:00+08:00">
                2019-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/a578e2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/posts/a578e2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>观察<code>Activity</code>栈的脚本:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity | sed -n -e '/Stack #/p' -e '/Running activities/,/Run #0/p'</span><br></pre></td></tr></table></figure>

<ul>
<li>Standard模式</li>
<li>SingleTop模式 栈顶复用</li>
<li>SingleTask模式 栈内复用</li>
<li>SingleInstance模式</li>
</ul>
<h2 id="Standard模式"><a href="#Standard模式" class="headerlink" title="Standard模式"></a>Standard模式</h2><p>标准模式, 启动<code>Activity</code>的默认模式, 被启动的<code>Activity</code>会运行于启动的<code>Activity</code>栈, 因此必须使用<code>Activity</code>的<code>Context</code>启动, 不能使用<code>Application</code>否则会报错.</p>
<p>如MainActivity启动TestAActivity</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    Stack #1:</span><br><span class="line">  <span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">    TaskRecord&#123;3caa65e3 #2711 A=me.chunyu.spike.wcl_activity_launchmode_demo U=0 sz=2&#125;</span><br><span class="line">      Run #1: ActivityRecord&#123;36b06e99 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestAActivity t2711&#125;</span><br><span class="line">      Run #0: ActivityRecord&#123;27396226 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.MainActivity t2711&#125;</span><br><span class="line">Stack #0:</span><br><span class="line">  <span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">    TaskRecord&#123;27d796c9 #2695 A=com.miui.home U=0 sz=1&#125;</span><br><span class="line">      Run #0: ActivityRecord&#123;2e5712cb u0 com.miui.home/.launcher.Launcher t2695&#125;</span><br></pre></td></tr></table></figure>

<p>栈内由上到下: MainActivity -&gt; TestAActivity</p>
<h2 id="SingleTop模式"><a href="#SingleTop模式" class="headerlink" title="SingleTop模式"></a>SingleTop模式</h2><p>栈顶复用模式, 只有<code>Activity</code>位于栈顶, 重复启动时，会使用默认实例， 即单例模式, 如果位于栈内，则会仍然创建实例</p>
<p>MainActivity启动TestA, TestA启动TestB, TestB启动自身， TestB是单例，观察栈内情况, TestB只有一份实例，第二次创建时复用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Stack #1:</span><br><span class="line"><span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">  TaskRecord&#123;12abf566 #2712 A=me.chunyu.spike.wcl_activity_launchmode_demo U=0 sz=3&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;187d7ff7 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestBActivity t2712&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;a551034 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestAActivity t2712&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;22f9cce4 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.MainActivity t2712&#125;</span><br></pre></td></tr></table></figure>

<p>栈内: MainActivity -&gt; TestAActivity -&gt; TestBActivity</p>
<p>MainActivity启动TestA, TestA启动TestB, TestB启动TestC, TestC启动TestB, TestB是单例, 观察栈内情况，由于TestC是栈定， 启动TestB之后， 因为TestB已经在栈内非栈顶了， 所以会重新创建TestB实例, 保留2份TestB</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  Stack #1:</span><br><span class="line"><span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">  TaskRecord&#123;1792f5f0 #2715 A=me.chunyu.spike.wcl_activity_launchmode_demo U=0 sz=5&#125;</span><br><span class="line">    Run #4: ActivityRecord&#123;1e70110b u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestBActivity t2715&#125;</span><br><span class="line">    Run #3: ActivityRecord&#123;c7f4dce u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestCActivity t2715&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;254536cd u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestBActivity t2715&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;36b2da15 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestAActivity t2715&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;3a1c4a6a u0 me.chunyu.spike.wcl_activity_launchmode_demo/.MainActivity t2715&#125;</span><br></pre></td></tr></table></figure>

<p>栈内: MainActivity -&gt; TestAActivity -&gt; TestBActivity -&gt; TestCActivity -&gt; TestBActivity</p>
<h2 id="SingleTask模式"><a href="#SingleTask模式" class="headerlink" title="SingleTask模式"></a>SingleTask模式</h2><p>栈内复用模式，只要<code>Activity</code>在一个栈中存在，多次调用时，都不会创建实例，即单例模式. 包含以下几种情况:</p>
<h3 id="任务栈不存在"><a href="#任务栈不存在" class="headerlink" title="任务栈不存在"></a>任务栈不存在</h3><p>初次启动SingleTask实例，会创建任务栈和实例</p>
<p>MainActivity启动TestA, TestA启动TestB, TestB是SingleTask, 并且任务栈不同，观察可知，系统包含两个任务栈，TestB位于其他任务栈中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Stack #1:</span><br><span class="line"><span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">  TaskRecord&#123;d5d53d4 #2727 A=me.chunyu.spike.stack U=0 sz=1&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;1d720e55 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestBActivity t2727&#125;</span><br><span class="line">  TaskRecord&#123;a3f797d #2726 A=me.chunyu.spike.wcl_activity_launchmode_demo U=0 sz=2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;ffd689d u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestAActivity t2726&#125;</span><br><span class="line">    Run #0: ActivityRecord&#123;192310ac u0 me.chunyu.spike.wcl_activity_launchmode_demo/.MainActivity t2726&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>taskAffinity</code>属性, 添加新的<code>Activity</code>栈, 与SingleTask配合使用, Standard模式无效. 新任务栈是<code>me.chunyu.spike.stack</code></p>
<h3 id="任务栈存在"><a href="#任务栈存在" class="headerlink" title="任务栈存在"></a>任务栈存在</h3><p>初次启动SingleTask实例，会直接进入栈， 剩下与Standard模式相同</p>
<h3 id="任务栈相同"><a href="#任务栈相同" class="headerlink" title="任务栈相同"></a>任务栈相同</h3><p>再次启动SingleTask实例， 实例会置于栈顶，并清除其上面的实例， 具有clearTop的效果.</p>
<p>MainActivity启动TestA, TestA启动TestB, TestB是SingleTask, TestB启动TestC, TestC重新启动TestB, 则TestB会出栈。 观察可知, TestC出栈，TestB在栈顶</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack #1:</span><br><span class="line">  <span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">    TaskRecord&#123;18230815 #2737 A=me.chunyu.spike.wcl_activity_launchmode_demo U=0 sz=3&#125;</span><br><span class="line">      Run #4: ActivityRecord&#123;1126c300 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestBActivity t2737&#125;</span><br><span class="line">      Run #3: ActivityRecord&#123;3114fee8 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestAActivity t2737&#125;</span><br><span class="line">      Run #2: ActivityRecord&#123;f8e235d u0 me.chunyu.spike.wcl_activity_launchmode_demo/.MainActivity t2737&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务栈不同"><a href="#任务栈不同" class="headerlink" title="任务栈不同"></a>任务栈不同</h3><p>再次启动SingleTask实例， 会导致任务栈切换，后台置于前台</p>
<p>MainActivity启动TestA, TestA启动TestB(SingleTask，不同任务栈), TestB启动TestC(与B同栈)。 则MainActivity和TestA想同栈， TestB和TestC相同栈， 此时栈顶是 TestC, 按Home键，再次启动应用，则默认任务栈会启动， TestA启动， TestA启动TestC，应用当前状态如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  Stack #1:</span><br><span class="line"><span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">  TaskRecord&#123;1d05e6c9 #2754 A=me.chunyu.spike.stack U=0 sz=2&#125;</span><br><span class="line">    Run #4: ActivityRecord&#123;3f77e822 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestCActivity t2754&#125;</span><br><span class="line">  TaskRecord&#123;3fe736d0 #2753 A=me.chunyu.spike.wcl_activity_launchmode_demo U=0 sz=2&#125;</span><br><span class="line">    Run #3: ActivityRecord&#123;15f0470e u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestAActivity t2753&#125;</span><br><span class="line">  TaskRecord&#123;1d05e6c9 #2754 A=me.chunyu.spike.stack U=0 sz=2&#125;</span><br><span class="line">    Run #2: ActivityRecord&#123;181229e6 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestBActivity t2754&#125;</span><br><span class="line">  TaskRecord&#123;3fe736d0 #2753 A=me.chunyu.spike.wcl_activity_launchmode_demo U=0 sz=2&#125;</span><br><span class="line">    Run #1: ActivityRecord&#123;28628d61 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.MainActivity t2753&#125;</span><br><span class="line">  TaskRecord&#123;2d646058 #2719 A=com.android.incallui U=0 sz=1&#125;</span><br></pre></td></tr></table></figure>

<p>TestC位于栈顶， 点击Back键, 不是返回TestA(启动TestC的实例)， 而是TestB, 即优先返回相同栈的实例, 再次是TestA, 然后是MainActivity, 依次出栈</p>
<h2 id="SingleInstance模式"><a href="#SingleInstance模式" class="headerlink" title="SingleInstance模式"></a>SingleInstance模式</h2><p>单实例模式， 启动时， 系统会为其创造一个单独的任务栈, 以后每次使用，都会使用这个单例， 直到其被销毁，属于真正的单例模式</p>
<p>MainActivity启动TestA, TestA启动TestB(SingleInstance模式), TestB启动TestC, TestC再启动TestB, 则仍启动上一次的TestB, TestC合并默认栈(MainActivity + TestA， 也就是MainActivity和TestA, TestC同栈，TestB在另一个栈，虽然TestC是TestB启动的，但是TestC与TestA同栈) 是不是可以理解为singleInstance栈里只能有一个实例?</p>
<p>TestA启动TestB(SingleInstance模式). Home键应用退到后台。此时再点击图标进入APP, 原则上认为是TestB先展示, 实际是TestA, 因为当重新启动的时候，系统会先去找主栈（我是这么叫的）里的activity，也就是APP中LAUNCHER的activity所处在的栈。查看是否有存在的activity。没有的话则会重新启动LAUNCHER</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stack #1:</span><br><span class="line">  <span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">    TaskRecord&#123;384e3928 #2765 A=me.chunyu.spike.wcl_activity_launchmode_demo U=0 sz=1&#125;</span><br><span class="line">      Run #3: ActivityRecord&#123;1ffc5b6b u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestBActivity t2765&#125;</span><br><span class="line">    TaskRecord&#123;2ad03544 #2764 A=me.chunyu.spike.wcl_activity_launchmode_demo U=0 sz=3&#125;</span><br><span class="line">      Run #2: ActivityRecord&#123;293d8c37 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestCActivity t2764&#125;</span><br><span class="line">      Run #1: ActivityRecord&#123;158bc0f3 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestAActivity t2764&#125;</span><br><span class="line">      Run #0: ActivityRecord&#123;77691cf u0 me.chunyu.spike.wcl_activity_launchmode_demo/.MainActivity t2764&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用标志位"><a href="#常用标志位" class="headerlink" title="常用标志位"></a>常用标志位</h2><ul>
<li><code>FLAG_ACTIVITY_NEW_TASK</code> 同 <code>singleTask</code>模式</li>
<li><code>FLAG_ACTIVITY_SINGLE_TOP</code> 同 <code>singleTop</code>模式</li>
<li><code>FLAG_ACTIVITY_CLEAR_TOP</code> 一般和<code>singleTask</code>启动模式一起出现<ul>
<li>如果是<code>singleTask</code>启动模式，会清楚栈上其他实例，复用实例，调用<code>onNewIntent()</code></li>
<li>如果是<code>standard</code>启动模式，则会清除自己和其他实例并重新创建，调用<code>onCreate</code></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.scions.cn/posts/5f491d88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ScorpioNeal">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ScorpioNeal's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/5f491d88/" itemprop="url">Translation-Analyze with Profile GPU Rendering</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-25T14:54:18+08:00">
                2019-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Translation/" itemprop="url" rel="index">
                    <span itemprop="name">Translation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/5f491d88/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/posts/5f491d88/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Analyze-with-Profile-GPU-Rendering"><a href="#Analyze-with-Profile-GPU-Rendering" class="headerlink" title="Analyze with Profile GPU Rendering"></a>Analyze with Profile GPU Rendering</h1><p>The <a href="https://developer.android.com/studio/profile/dev-options-rendering.html" target="_blank" rel="noopener">Profile GPU Rendering</a> too indicates the relative time that each stage of the rendering pipeline takes to render the previous frame. This knowledge can help you identify bottlenecks in the pipeline, so that you can know what to optimize to improve your app’s rendering performance.</p>
<p>This page briefly explains what happens during each pipeline stage, and discusses issues that can cause bottlenecks there. Before reading this page, you should be familiar with the information presented in <a href="https://developer.android.com/studio/profile/dev-options-rendering.html" target="_blank" rel="noopener">Profile GPU rendering</a>. In addition, to understand how all of the stages fit together, it may be helpful to review <a href="https://www.youtube.com/watch?v=we6poP0kw6E&index=64&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="noopener">how the rendering pipeline works</a></p>
<h2 id="Visual-representation"><a href="#Visual-representation" class="headerlink" title="Visual representation"></a>Visual representation</h2><p>The Profile GPU Rendering tool displays stages and their relative times in the form of a graph: a color-coded histogram.</p>
<p><img src="https://developer.android.com/topic/performance/images/bars.png" alt="an example of such a display"></p>
<p>Each segment of each vertical bar displayed in the Profile GPU Rendering graph represents a stage of the pipeline and is highlighted using a specific color in the bar graph. Figuer shows a key to the meaning of each displayed color.</p>
<p><img src="https://developer.android.com/topic/performance/images/s-profiler-legend.png" alt="Profile GPU Rendering Graph Legend"></p>
<p>Once you understant what each color signfiles, you can target specific aspects of your app to try to optimize its rendering performance.</p>
<h2 id="Stage-and-their-meanings"><a href="#Stage-and-their-meanings" class="headerlink" title="Stage and their meanings"></a>Stage and their meanings</h2><p>This section explains what happens during each stage corresponding to a color in Figure 2, as well as bottleneck causes to look out for.</p>
<h3 id="Input-Handling"><a href="#Input-Handling" class="headerlink" title="Input Handling"></a>Input Handling</h3><p>The input handling stage of the pipeline measures how long the app spent handling input events. This metric indicates how long the app spent executing code called as a result of input event callbacks.</p>
<p><code>When this segment is large</code></p>
<p>High values in this area are typically a result of too much work, or too-complex work, occuring inside the input-handler event callbacks. Since these callbacks always occur on the main thread, solutions to this problem focus on optimizing the work directly, or offloading the work to a different thread.</p>
<p>It’s also worth nothing that <code>RecyclerView</code> scrolling can appear in this phase. <code>RecyclerView</code> scrolls immediately when it consumes the touch event. As a result, it can inflate or populate new item views. For this reason, it’s important to make this operation as fast as possible. Profiling tools like <a href="https://developer.android.com/studio/profile/traceview.html" target="_blank" rel="noopener">Traceview</a> or <a href="https://developer.android.com/studio/profile/systrace.html" target="_blank" rel="noopener">Systrace</a> can help you investigate further.</p>
<h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p>The Animations phase shows you just how long it took to evaluate all the animators that were running in that frame. The most common animators are <code>ObjectAnimator</code>, <code>ViewPropertyAnimator</code>, and <code>Transions</code>.</p>
<p><code>When this segment is large</code></p>
<p>High values in this area are typically a result of work that’s executing due to some property change of the animation. For example, a fling animation, which scrolls your <code>ListView</code> or <code>RecyclerView</code>, causes large amounts of view inflation and populaion.</p>
<h3 id="Measurement-Layout"><a href="#Measurement-Layout" class="headerlink" title="Measurement / Layout"></a>Measurement / Layout</h3><p>In order for Android to draw your view items on the screen, it executes two sepecific operations across layouts and views in your view hierarchy.</p>
<p>First, the system measures the view items. Every view and layout has specific data that describes the size of the object on the screen. Some views can have a specific size; others have a size that adapts to the size of the parent layout container.</p>
<p>Second, the system lays out the view item. Once the system calculates the sizes of children views, the system can proceed with layout, sizing and positioning the views on the screen.</p>
<p>The system perfrms measurement and layout not only for the views to be drawn, but also for the parent hierarchies of those views, all the way up to the root view.</p>
<p><code>When this segement is large</code></p>
<p>If your app spends a lot of time per frame in this area, it usually either because of the sheer volume of views that need to be laid out, or problems such as <a href="https://developer.android.com/topic/performance/optimizing-view-hierarchies.html#double" target="_blank" rel="noopener">double taxation</a> at the wrong spot in your hierarchy. In either of these cases, addressing performance involves <a href="https://developer.android.com/topic/performance/optimizing-view-hierarchies.html" target="_blank" rel="noopener">improving the proformance of your view hierarchies</a></p>
<p>Code that you’ve added to <code>onLayout(boolean, int, int, int, int)</code> or <code>onMeasure(int, int)</code> can also cause performace issues. <a href="https://developer.android.com/studio/profile/traceview.html" target="_blank" rel="noopener">TraceView</a> and <a href="https://developer.android.com/studio/profile/systrace.html" target="_blank" rel="noopener">Systrace</a> can help you examine the callstacks to identify problems your code may have.</p>
<h3 id="Draw"><a href="#Draw" class="headerlink" title="Draw"></a>Draw</h3><p>The draw stage translates a view’s rendering operations, such as drawing a background or drawing text, into a sequence of native drawing commands. The system captures these commands into a display list.</p>
<p>The Draw bar records how much time it takes to complete capturing the commands into the display list, for all the views that needed to be updated on the screen this frame. This measured time applies to any code that you have added to the UI objects in your app. Examples of such code may be the <code>onDraw()</code>, <code>dispatchDraw()</code> and the various <code>draw() methods</code> belonging to the subclasses of the <code>Drawable</code> class.</p>
<p><code>When this segment  is large</code></p>
<p>In simplified terms, you can understand this metric as showing how long it tooks to run all of the calls to <code>onDraw()</code> for each invalidated view. This measurement includes any time spent dispatching draw commands to children and drawable that may be present. For this reason, when you see this bar spike, the  cause could be that a bunch of views suddenly became invalidated. Invalidation makes it necessary to regenerate views’ display lists. Alertnatively, a lengthy time may be the result of a few custom views that have some extremely complex logic in their <code>onDraw()</code> method.</p>
<h3 id="Sync-upload"><a href="#Sync-upload" class="headerlink" title="Sync/upload"></a>Sync/upload</h3><p>The Sync &amp; Upload metric represents the time it takes to transfer bitmap objects from CPU memory to GPU memory during the current frame.</p>
<p>As different processors, the CPU and the GPU have different RAM areas dedicated to processing. When you draw a bitmap on Android, the system transfers the bitmap to GPU memory before the GPU can render it to the screen. Then, the GPU caches the bitmap so that the system doesn’t need to transfer the data again unless the texture gets evicted from the GPU texture cache.</p>
<p><code>When this segment is large</code></p>
<p>All resources for a frame need to reside in GPU memory before they can be used to draw a frame. This means that a high value for this metric could mean either a large number of small resource loads or a small number of very large resources.  A common case is when an app displays a single bitmap that’s close to the size of the screen. Another case is when an app displays a large number of thumbnails.</p>
<p>To shrink this bar, you can emply techniques such as :<br>    * Ensureing your bitmap resolutions are not much larger than the size at which they will be displayed. For example, your app should avoid displaying a 1024 * 1024 image as a 48 * 48 image.<br>    * Taking advantage of <code>prepareToDraw()</code> to asynchronously pre-upload a bitmap before the next sync phase.</p>
<p>Tips: On Lollipop devices, this stage is purple.</p>
<h3 id="Issue-commands"><a href="#Issue-commands" class="headerlink" title="Issue commands"></a>Issue commands</h3><p>The Issue Commands segment represents the time it takes to issue all of the commands necessary for drawing display lists to the screen.</p>
<p>For the system to draw display lists to the screen, it sends the necessary commands to the GPU. Typically, it performs this action through the <a href="https://developer.android.com/guide/topics/graphics/opengl.html" target="_blank" rel="noopener">OpenGL ES</a> API.</p>
<p>This process takes some time, as the system performs final transformation and clipping for each command before sending the command to the GPU. Additional overhead then arises on the GPU side, which computes the final commands. These commands include final transformations, adn additional clipping.</p>
<p><code>When this segement is large</code><br>The time spent in this stage is a direct measure of the complexity and quantity of display list that the system renders in a given frame. For example, having many draw operations, especially in cases where there’s a small inherent cost to each draw primitive, could inflate this time. For example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    canvas.drawPoint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>is a lot more expensive to issue than:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.drawPoints(thousandPointArray);</span><br></pre></td></tr></table></figure>

<p>There isn’t always a 1:1 correlation between issuing commands and actually drawing display lists. Unlike Issue Commands, which captures the time it takes to send drawing commands to the GPU, the Draw metric represents the time that it took to capture the issued commands into the display list.</p>
<p>This difference arises because the display lists are cached by the system wherever possible. As a result, there are situations where a scroll, transform, or animation requires the system to re-send a display list, but not have to acutally rebuild it-recapture the drawing commands- from scratch. As a result , you can see a hight <code>Issue Commands</code> bar without seeing a high Draw commands bar.</p>
<h3 id="Process-swap-buffers"><a href="#Process-swap-buffers" class="headerlink" title="Process/swap buffers"></a>Process/swap buffers</h3><p>Once Android finishes submitting all its display list to the GPU, the system issues one final command to tell the graphics driver that it’s done with the current frame. At this point, the driver can finally present the update image to the screen.</p>
<p><code>When this segment is large</code></p>
<p>It’s important to understant that the GPU executes work in parallel with the CPU. The Android system issues draw commands to the GPU, and the n moves on to the next task. The GPU reads those draw commands from a queue and processes them.</p>
<p>In situations where the CPU issues commands faster than the GPU consumes them, the communications queue between the processors can become full. When this occurs, the CPU blocks, and waits unitl there is space in the queue to place the next command. This full-queue state arises often during the <code>Swap buffers</code> stage, because at that point, a whole frame’s worth of commands have been submitted.</p>
<p>The key to mitigating this problem is to reduce the complexity of work occuring on the GPU, in similar fashion to what you would do for the <code>Issue Commands</code> phase.</p>
<h3 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h3><p>In addition to the time it takes the rendering system to perform its work, there’s an additional set of work that occurs on the main thread and has nothing to do with rendering.  Time that this work consumes is reported as <code>misc time</code>. Misc time generally represents work that might be occuring on the UI thread between two consecutive frames of rendering.</p>
<p><code>When this segment is large</code></p>
<p>If this value is high, it is likely your app has callbacks, intents, or other work that should be happening on another thread. Tools such <a href="https://developer.android.com/studio/profile/traceview.html" target="_blank" rel="noopener">Method tracing</a> or <a href="https://developer.android.com/studio/profile/systrace.html" target="_blank" rel="noopener">Systrace</a> can provide visibility into the tasks that are running on the main thread. This informaiton can help you target performance improvements.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.scions.cn/posts/d96da03e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ScorpioNeal">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ScorpioNeal's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/d96da03e/" itemprop="url">Android UI优化常用工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-25T13:45:36+08:00">
                2019-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/d96da03e/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/posts/d96da03e/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>Analyze with Profile GPU Rendering</li>
<li>TraceView</li>
<li>Systrace</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.scions.cn/posts/5c71151a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ScorpioNeal">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ScorpioNeal's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/5c71151a/" itemprop="url">Android-View的绘制流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-24T13:46:32+08:00">
                2019-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/5c71151a/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/posts/5c71151a/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>View的绘制流程是从<code>ViewRootImpl.java</code>中的<code>performTraversales()</code>函数开始的。</p>
<p>包括以下三个阶段</p>
<ul>
<li>measure</li>
<li>layout</li>
<li>draw</li>
</ul>
<h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><p>用于测量<code>view</code>的大小, <code>View</code>中的<code>measure</code>方法，接收2个参数, <code>widthMeasureSpec</code>和<code>heightMeasureSpec</code></p>
<p><code>MeasureSpec</code>由<code>specSize</code>和<code>specMode</code>构成，<code>specSize</code>表示大小, <code>specMode</code>表示规格, 有三种情况</p>
<ul>
<li>EXACTLY 表示父布局希望子布局的大小由specSize决定<ul>
<li>Measure specification mode: The parent has determined an exact size for the child. The child is going to be given those bounds regardless of how big it wants to be.</li>
</ul>
</li>
<li>AT_MOST 表示子布局最大只能是specSize中指定的大小 <ul>
<li>Measure specification mode: The child can be as large as it wants up to the specified size.</li>
</ul>
</li>
<li>UNSPECIFIED 没有限制 <ul>
<li>Measure specification mode: The parent has not imposed any constraint on the child. It can be whatever size it wants. widthMeasureSpec和heightMeasureSpec由父view计算后传给子view, 也就是说父View在一定程度上决定子view的大小。</li>
</ul>
</li>
</ul>
<p>其中, rootView的measureSpec是这么来的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);  </span><br><span class="line">    childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span>      rootDimension)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> measureSpec;  </span><br><span class="line">        <span class="keyword">switch</span> (rootDimension) &#123;  </span><br><span class="line">            <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:  </span><br><span class="line">                measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:  </span><br><span class="line">                measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">default</span>:  </span><br><span class="line">                measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> measureSpec;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  View.java</span><br><span class="line">  <span class="comment">// final的方法，不允许override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      measure();</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">      setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">              getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  setMeasuredDimension()之后，getMeasuredWidht&amp;Height才有值，否则为<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h2><p>给视图进行布局</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">host.layout(<span class="number">0</span>, <span class="number">0</span>, host.mMeasuredWidth, host.mMeasuredHeight);</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    onLayout(changed, l, t, r, b);</span><br><span class="line">    <span class="comment">// getWidth = r - l;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">View.java</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//View中是个空方法, 因为onLayout()过程是为了确定视图在布局中的位置，而这个操作应该有布局来完成.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ViewGroup.java</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="comment">// 也就是说ViewGroup子类必须重写这个方法</span></span><br></pre></td></tr></table></figure>

<p><code>view</code>在<code>onLayout()</code>之后，就可以调用<code>getWidth()</code>和<code>getHeight()</code>方法来获取<code>View</code>的宽高。</p>
<p>Tips: getWidth()和getMeasuredWidth()的区别</p>
<p>首先 <code>getMeasuredWidth()</code>方法在<code>measure()</code>过程结束后就可以获取到了，而<code>getWidth()</code>方法要在<code>layout()</code>之后才能拿到。另外, <code>getMeasuredWidth()</code>方法的值是通过<code>setMeasuredDimension()</code>方法进行设置的而<code>getWidth()</code>方法返回的值则是通过视图右坐标减去左坐标计算得到的。</p>
<h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><p>绘制过程</p>
<p><code>invalidate()</code>方法虽然最终会调用到<code>performTraversals()</code>方法中。但这时<code>measure</code>和<code>layout</code>流程是不会重新执行的， 因为视图没有强制重新测量的标志，而且大小也没有发生过变化，所以这时只有<code>draw</code>流程执行。</p>
<p>而如果你希望视图的绘制流程可以完整的走一遍，就要使用<code>requestLayout()</code>而不是<code>invalidate()</code></p>
<p>每次绘制的时候并不会重新绘制所有的<code>View Tree</code>视图，而是去绘制需要重绘的(View内部的标示位DRAWN)</p>
<p>流程:</p>
<ol>
<li>绘制View背景</li>
<li>渐变框作准备???</li>
<li>onDraw()</li>
<li>dispatchDraw() 遍历每个子视图， 绘制子视图draw()</li>
<li>绘制滚动条</li>
</ol>
<p>View坐标系</p>
<p><img src="http://img-scions.test.upcdn.net/view.jpeg" alt="View坐标系"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.scions.cn/posts/7053c23b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ScorpioNeal">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ScorpioNeal's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/7053c23b/" itemprop="url">Android-AsyncLayoutInflator原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-24T10:50:01+08:00">
                2019-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/7053c23b/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/posts/7053c23b/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AsyncInflatInflator源码其实很简单。 </p>
<p>总结来说，就是开启一个线程，进行inflate操作，如果inflate失败，会调用原有线程的inflate操作. inflate成功后返回view, 没有attachToRoot, 需要自己去处理.<br>内部原理需要注意的地方，都以注释方式加上了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncLayoutInflater</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"AsyncLayoutInflater"</span>;</span><br><span class="line"></span><br><span class="line">    LayoutInflater mInflater;</span><br><span class="line">    Handler mHandler;</span><br><span class="line">    InflateThread mInflateThread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncLayoutInflater</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原来的inflater</span></span><br><span class="line">        mInflater = <span class="keyword">new</span> BasicInflater(context);</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler(mhandlerCallback);</span><br><span class="line">        <span class="comment">// 单线程</span></span><br><span class="line">        mInflateThread = InflateThread.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UiThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resid, @Nullable ViewGroup parent, @NonNull OnInflateFinishedListener callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == callback) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"callback argument may not be null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        InflateRequest request = mInflateThread.obtainRequest();</span><br><span class="line">        request.inflater = <span class="keyword">this</span>;</span><br><span class="line">        request.resid = resid;</span><br><span class="line">        request.parent = parent;</span><br><span class="line">        request.callback = callback;</span><br><span class="line">        mInflateThread.enqueue(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnInflateFinishedListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onInflateFinished</span><span class="params">(@NonNull View view, @LayoutRes <span class="keyword">int</span> resid,</span></span></span><br><span class="line"><span class="function"><span class="params">                               @Nullable ViewGroup parent)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InflateRequest</span> </span>&#123;</span><br><span class="line">        AsyncLayoutInflater inflater;</span><br><span class="line">        ViewGroup parent;</span><br><span class="line">        <span class="keyword">int</span> resid;</span><br><span class="line">        View view;</span><br><span class="line">        OnInflateFinishedListener callback;</span><br><span class="line"></span><br><span class="line">        InflateRequest() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler.Callback mhandlerCallback = <span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            InflateRequest request = (InflateRequest)msg.obj;</span><br><span class="line">            <span class="keyword">if</span>(request.view == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果inflate失败，会调用原来的inflater去inflate布局</span></span><br><span class="line">                <span class="comment">// 而且没有attachToRoot, 需要自己去处理返回的request.view</span></span><br><span class="line">                request.view = mInflater.inflate(request.resid, request.parent, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            request.callback.onInflateFinished(request.view, request.resid, request.parent);</span><br><span class="line">            mInflateThread.releaseRequest(request);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicInflater</span> <span class="keyword">extends</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] sClassPrefixList = &#123;</span><br><span class="line">                <span class="string">"android.widget."</span>,</span><br><span class="line">                <span class="string">"android.webkit."</span>,</span><br><span class="line">                <span class="string">"android.app."</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        BasicInflater(Context context) &#123;</span><br><span class="line">            <span class="keyword">super</span>(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">cloneInContext</span><span class="params">(Context newContext)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BasicInflater(newContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(String prefix : sClassPrefixList) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 不是很清楚这里</span></span><br><span class="line">                    View view = createView(name, prefix, attrs);</span><br><span class="line">                    <span class="keyword">if</span>(view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> view;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InflateThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InflateThread sInstance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> InflateThread();</span><br><span class="line">            sInstance.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InflateThread <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sInstance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//阻塞队列， 如果inflate request超过10个会阻塞</span></span><br><span class="line">        <span class="keyword">private</span> ArrayBlockingQueue&lt;InflateRequest&gt; mQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;InflateRequest&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象池， 不用多次创建对象，内存优化</span></span><br><span class="line">        <span class="keyword">private</span> Pools.SynchronizedPool&lt;InflateRequest&gt; mRequestPool = <span class="keyword">new</span> Pools.SynchronizedPool&lt;InflateRequest&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                runInner();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            InflateRequest request;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                request = mQueue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                request.view = request.inflater.mInflater.inflate(request.resid, request.parent, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送给调用处的handler</span></span><br><span class="line">            Message.obtain(request.inflater.mHandler, <span class="number">0</span>, request).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> InflateRequest <span class="title">obtainRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            InflateRequest obj = mRequestPool.acquire();</span><br><span class="line">            <span class="keyword">if</span>(obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                obj = <span class="keyword">new</span> InflateRequest();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(InflateRequest request)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mQueue.put(request);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Failed to enqueue async inflate request"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseRequest</span><span class="params">(InflateRequest obj)</span> </span>&#123;</span><br><span class="line">            obj.callback = <span class="keyword">null</span>;</span><br><span class="line">            obj.inflater = <span class="keyword">null</span>;</span><br><span class="line">            obj.parent = <span class="keyword">null</span>;</span><br><span class="line">            obj.resid = <span class="number">0</span>;</span><br><span class="line">            obj.view = <span class="keyword">null</span>;</span><br><span class="line">            mRequestPool.release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.scions.cn/posts/db834188/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ScorpioNeal">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ScorpioNeal's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/db834188/" itemprop="url">Android 抽象布局的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-24T09:41:49+08:00">
                2019-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/db834188/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/posts/db834188/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ul>
<li>include</li>
<li>merge</li>
<li>viewstub</li>
</ul>
<h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><p>重用布局文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/layout_file"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以在<code>include</code>中指定<code>id</code>， 如果这样，会覆盖<code>layout_file</code>中的<code>id</code></p>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>减少视图层级, 多用于替换<code>FramenLayout</code>或者当一个布局包含另一个时</p>
<p>Since the <code>FrameLayout</code> has the same dimension as its parent, by the virtue of using the <code>match_parent</code> constraints, and does not define any background, extra padding or a gravity, it is totally useless, we can use merge tag to replace it. (也就是说，当前布局根布局如果使用的是<code>Framelayout</code>而且与父布局完全一致，那么当前这层布局的根布局就可以省略，使用<code>merge</code>代替)</p>
<p>When the <code>LayoutInflater</code> encounters this tag, it skips it and adds the <code>&lt;merge/&gt;</code> children to the <code>&lt;merge/&gt;</code> parent. (当<code>LayoutInflater</code>解析<code>xml</code>时，如果遇到了<code>merge</code>标签，那么他会忽略这个标签，而是把他的子布局添加到他的父布局里，具体参见<a href>setContentView与LayoutInflater加载解析机制源码解析</a>)</p>
<p>You can’t use this trick if your layout was using a <code>LinearLayout</code> as its root tag. (根布局使用<code>LinearLayout</code>的时候不能用merge替代)</p>
<p><code>&lt;merge&gt;</code> can only be used as the root tag of an XML layout.(<code>merge</code>标签只能用于根布局)</p>
<p>When inflating a layout starting with a <code>&lt;merge/&gt;</code>, you must specify a parent ViewGroup and you must set attachToRoot to true.(使用<code>LayoutInflater</code>解析<code>xml</code>时，如果<code>xml</code>以<code>merge</code>开始，你必须在解析时指定<code>parent viewgroup</code>和<code>attachToRoot = true</code>)</p>
<h2 id="viewstub"><a href="#viewstub" class="headerlink" title="viewstub"></a>viewstub</h2><p>需要的时候才加载</p>
<p>It has no dimension, it does not draw anything and does not participate in the layout in any way.</p>
<p><code>ViewStub</code>只能<code>inflate</code>一次，之后<code>ViewStub</code>对象就会被置为空, 换句话说，某个被<code>ViewStub</code>指定的布局被<code>inflate</code>后，就不能再通过<code>ViewStub</code>来控制它了.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ViewStub</span>&gt;</span></span><br><span class="line">  android:id=""</span><br><span class="line">  android:layout="to refreence what layout file to include and inflate"</span><br><span class="line">  android:inflatedId="can be used to override the id of the root of the included file"</span><br><span class="line"><span class="tag">&lt;/<span class="name">ViewStub</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>When you are ready to inflate the stub, simply invoke the inflate() method. you can also simply change the visiblity of the stub to VISIBLE or INVISIBLE and the stub will inflate.(使用的时候，你可以通过<code>inflate()</code>方法来加载这个布局，也可以简单的通过设置 <code>VISIBLE</code>和<code>INVISIBLE</code>来控制)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.scions.cn/posts/290d3103/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ScorpioNeal">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ScorpioNeal's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/290d3103/" itemprop="url">Java- 《Java编程的逻辑》_容器类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-21T09:10:18+08:00">
                2019-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/290d3103/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/posts/290d3103/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Collections子接口"><a href="#Collections子接口" class="headerlink" title="Collections子接口"></a>Collections子接口</h2><p><img src="http://img-scions.test.upcdn.net/Collection.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.scions.cn/posts/c8a24b3d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ScorpioNeal">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ScorpioNeal's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/posts/c8a24b3d/" itemprop="url">Java-《Java编程的逻辑》- 并发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-19T10:38:04+08:00">
                2019-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/c8a24b3d/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/posts/c8a24b3d/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="并发总结"><a href="#并发总结" class="headerlink" title="并发总结"></a>并发总结</h1><p>多线程2个核心问题， <code>竞争</code>和<code>协作</code></p>
<ul>
<li><p>竞争 -&gt; 线程安全的机制</p>
<ul>
<li>synchronized</li>
<li>显示锁</li>
<li>volatile</li>
<li>原子变量和CAS</li>
<li>写时复制 CopyOnWriteArrayList, 讲共享变量变成只读的，写的时候再需要锁, 写的线程不是直接修改原对象，而是创建一个对象，对该对象修改完毕后再原子性的修改共享访问的变量，让他指向新的对象</li>
<li>ThreadLocal</li>
</ul>
</li>
<li><p>协作 -&gt; 线程的协作</p>
<ul>
<li>wait/notify</li>
<li>显示条件</li>
<li>线程的中断</li>
<li>协作工具类 Semaphore, CountDownLatch, CyclicBarrier</li>
<li>并发队列</li>
<li>Future/FutureTask</li>
</ul>
</li>
<li><p>容器类</p>
<ul>
<li>写时复制的List&amp;Set</li>
<li>ConcurrentHashMap</li>
<li>基于SkipList的Map &amp; Set</li>
</ul>
</li>
<li><p>任务执行服务</p>
<ul>
<li>Runnable, Callable, Executor, ExecutorService, Future etc</li>
<li>线程池</li>
<li>定时任务</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>Java7引入的Fork&amp;Join</li>
<li>Java8并行流</li>
<li>CompletionService</li>
<li>Java8引入的CompletableFuture</li>
<li>…</li>
</ul>
</li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>线程表示一条单独的执行流，他有自己的程序计数器，有自己的栈.</p>
<p>Que: 为什么调用的是start, 执行的却是run呢?<br>Ans: start表示启动该线程，使其成为一条单独的执行流，操作系统会分配线程相关的资源, 每个线程都会有单独的程序计数器和栈，操作系统会把这个线程作为一个独立的个体进行调度，分配时间片让他执行，执行的起点就是run方法 。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>通过<code>public State getState()</code>获取，有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">	NEW, <span class="comment">//没有调用start的线程</span></span><br><span class="line">	RUNNABLE, <span class="comment">//调用start后的线程且没有阻塞时的状态</span></span><br><span class="line">	BLOCKED, </span><br><span class="line">	WAITING,</span><br><span class="line">	TIMED_WAITING,</span><br><span class="line">	TERMINATED <span class="comment">//运行结束后的状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BLOCKED, WAITING, TIMED_WAITING都是阻塞时的状态</span></span><br></pre></td></tr></table></figure>

<p>通过<code>public final boolean isAlive()</code>获取线程是否活着，启动后，run运行完之前都是alive</p>
<h3 id="deamon线程"><a href="#deamon线程" class="headerlink" title="deamon线程"></a>deamon线程</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Thread.sleep. 让当前线程睡眠指定时间，但这个时间不一定是确切的给定毫秒数。与系统精度有关。 睡眠期间，线程可以被中断，如果被中断，sleep会抛出InterruptedException<br>Thread.yield. 让出CPU, 告诉CPU当前线程不着急占用CPU,不可以依赖此方法<br>Thread.join. 可以让调用join的线程等待该线程结束。join() -&gt; waits for this thread to die</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">e.g </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">	Thread thread = <span class="keyword">new</span> HelloWorldThread();</span><br><span class="line">	thread.start();</span><br><span class="line">	thread.join();  <span class="comment">// main线程等待thread执行完后才结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//blog.csdn.net/programmer_at/article/details/78934278</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Thread t1 = <span class="keyword">new</span> ChildThread(list);</span><br><span class="line">       Thread t2 = <span class="keyword">new</span> ChildThread(list);</span><br><span class="line">       t1.start();</span><br><span class="line">       t2.start();</span><br><span class="line">       t1.join(); <span class="comment">//这里t1和t2会轮流执行，而不是t2在t1执行完后再执行，因为join阻塞的是这个join方法调用所在的线程，也就是main线程</span></span><br><span class="line">       t2.join();</span><br><span class="line">       System.out.println(shared);</span><br><span class="line">       System.out.println(list);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h2><p>多条执行流操作相同变量的时候会出现一些异常问题:</p>
<ul>
<li>竞态条件 race condition</li>
<li>内存可见性问题   都个线程可以共享访问和操作相同的变量，但一个线程对一个共享变量的修改，另一个线程不一定可以马上就能看到，甚至永远看不到。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">e.g 内存可见性问题</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisiblityDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> shutdown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">       	<span class="meta">@Override</span></span><br><span class="line">       	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           	<span class="keyword">while</span> (!shutdown) &#123;</span><br><span class="line"></span><br><span class="line">           	&#125;</span><br><span class="line">           	System.out.println(<span class="string">"exit hello"</span>);</span><br><span class="line">       	&#125;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       	<span class="keyword">new</span> HelloWorld().start();</span><br><span class="line">       	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       	shutdown = <span class="keyword">true</span>;</span><br><span class="line">       	System.out.println(<span class="string">"exit main"</span>);</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">期望结果HelloThread在shutdown为<span class="keyword">true</span>的时候结束并输出exit hello, main结束并输出exit main</span><br><span class="line">实际执行时候可能发现, HelloThread永远都不会退出，也就是HelloThread执行流看shutdown永远为<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">内存可见性问题: 在计算机系统中，除了内存，数据还会被缓存在CPU的寄存器以及各级缓存中，当访问一个变量的时候，可能直接从寄存器或CPU缓存中获取，而不一定到内存中去取，当修改一个变量时，也可能是先写到缓存中，稍后才会同步更新到内存中。在单线程的程序里，这一般不是问题，但是在多线程程序里，尤其是在有多CPU的情况下，一个线程对内存的修改，另一个线程看不到，一是修改没有及时同步到内存，二是另一个线程根本没有从内存里读取。</span><br><span class="line"></span><br><span class="line">解决方法:</span><br><span class="line">	<span class="number">1</span>. 使用volitile关键字</span><br><span class="line">	<span class="number">2</span>. 使用<span class="keyword">synchronized</span>关键字或者显示锁同步。</span><br></pre></td></tr></table></figure>

<p>线程调度和切换是有成本的. 一个线程被切换出去后，操作系统需要保存它的当前上下文状态到内存，上下文状态包括当前CPU寄存器的值,程序计数器的值等，而一个线程被切换回来后，OS需要恢复它原来的上下文状态，整个过程称为 <code>上下文切换</code>， 这个切换不仅耗时，而且使CPU中的很多缓存失效. </p>
<p>如果执行的任务是CPU密集型的，即主要消耗的都是CPU，那创建超过CPU数量的线程就是没有必要的，并不会加快程序的执行。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><code>synchronized实例方法</code> 实际保护的是同一个对象的方法调用，确保同时只能有一个线程执行。 或者说，<code>synchronized实例方法</code>保护的是当前实例对象, 即this对象, this对象有一个锁和一个等待队列， 锁只能被一个线程持有，其他试图获得同样的锁的线程需要等待。 过程大致如下:</p>
<ol>
<li>尝试获取锁，如果获取到了，进行下一步，否则加入等待队列阻塞并等待被唤醒</li>
<li>执行实例方法体代码</li>
<li>释放锁，如果等待队列上有等待的线程，从中选取一个进行唤醒，如果有多个线程等待，唤醒哪个是不确定的，不保证公平性，也就是不保证等待久的先被唤醒</li>
</ol>
<p>synchronized不能防止非synchronized方法被同时执行，因此，一般在保护变量时， 需要在所有访问该变量的方法上加上synchronized。</p>
<p>synchronized同步的对象可以是任意对象，任意对象都有一个锁和等待队列。</p>
<p>synchronized特性：</p>
<ul>
<li>可重入性, 对同一个执行线程，他在获得了锁之后，在调用其他需要同样锁的代码时，可以直接调用，比如，在一个synchronized实例方法内，可以直接调用其他synchronized实例方法。但是并不是所有的锁都是可重入的。 可重入锁是通过记录锁的持有线程和持有数量来实现的， 当调用被synchronized保护的代码时，检查对象是否已被锁，如果是，再检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待队列，释放锁时，减少持有数量，当数量变为0才释放整个锁。</li>
<li>内存可见性。释放锁时，所有写入都会写回内存，获取锁后，都会从内存里读取最新数据, 但是只是为了保证内存可见性，使用synchronized成本有点高，使用轻量级的volitile就可以了</li>
</ul>
<p>死锁，A等待B的锁释放，B等待A的锁释放导致，AB陷入互相等待。所以应该避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请。或者使用显示锁Lock, 它支持tryLock和带时间限制的获取锁的方法来避免死锁</p>
<h3 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h3><p>锁接口 Lock, 主要实现类ReentrantLock<br>读写锁接口ReadWriteLock, 主要实现类ReentrantReadWriteLock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>/<span class="title">unlock</span><span class="params">()</span></span>;   普通的获取锁和释放锁, lock会阻塞直到成功</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InteruptedException</span>; 可以响应中断的lock, 如果被其他线程中断了，会抛出InterruptedException</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>; 尝试获取锁，立即返回，不阻塞，成功返回<span class="keyword">true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; 先尝试获取锁 如果成功立即返回<span class="keyword">true</span>, 否则阻塞等待time时间，会响应中断</span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>; 新建一个条件, 一个lock可以关联多个条件</span><br></pre></td></tr></table></figure>

<p>相比synchronized, lock可以以非阻塞的形式获取锁，响应中断，限时，更加灵活</p>
<h3 id="可重入锁-ReentrantLock"><a href="#可重入锁-ReentrantLock" class="headerlink" title="可重入锁 ReentrantLock"></a>可重入锁 ReentrantLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span>; <span class="comment">//是否保证公平，默认为false. 公平表示，等待最长的线程优先获取锁，这个机制会影响性能，默认不保证</span></span><br></pre></td></tr></table></figure>

<p>一般把lock之后的代码放入try中，finally里释放锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	counter++;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryLock<br>使用tryLock()可以避免死锁，在持有一个锁获取另一个锁而获取不到的时候，可以释放已有的锁，给其他线程获取锁的机会，然后重试获取所有锁</p>
<p>ReentrantLock实现原理<br>依赖CAS方法以及LockSupport类中的一些方法. //TODO 未细看</p>
<p>synchronized代表一种声明式编程思维，显示锁代表一种命令式编程思维。 简单总结就是能用synchronized就用synchronized,不满足条件是再考虑ReentrantLock</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h3 id="原子变量和CAS"><a href="#原子变量和CAS" class="headerlink" title="原子变量和CAS"></a>原子变量和CAS</h3><p>对于使用synchronized来保证原子更新操作的成本太高了，一些情况下可以直接使用原子变量代替</p>
<p>AutomicBoolean , AtomicInteger, AtomicLong, AtomicReference等等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                counter.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1000</span>;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Visitor();</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(counter.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里总是会输出正确结果 1000000</span></span><br></pre></td></tr></table></figure>

<p>原理如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要内部成员为:</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(; ;) &#123;</span><br><span class="line">		<span class="keyword">int</span> current = get();</span><br><span class="line">		<span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(compareAndSet(current, next)) &#123;</span><br><span class="line">			<span class="keyword">return</span> next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">先调取当前值current, 计算期望值next, 然后调用CAS进行更新，如果更新没有成功，说明value被别的线程更改了，则再去取最新值并尝试更新直到成功为止。</span><br><span class="line">一般应用程序不应该直接调用CAS, 原理上一般的操作系统在硬件层次上都支持CAS指令 </span><br><span class="line">具体CAS解析 </span><br><span class="line">CAS有<span class="number">3</span>个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment">    * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true if successful. False return indicates that</span></span><br><span class="line"><span class="comment">    * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   这里的<span class="keyword">this</span>结合valueOffset则就是AtomicInteger的实际值，而current是线程修改时用到的初值，如果实际值和初值一致，则说明当前并没有人修改AtomicInteger，故当前修改有效，那么就可以继续赋值为update。</span><br></pre></td></tr></table></figure>

<p>synchronized是悲观的，假定更新很可能冲突，所以先获取锁，得到锁后才更新，是一种阻塞式算法。 原子变量的更新逻辑是乐观的，假定冲突比较少，即使又冲突，继续尝试就好了。是非阻塞式的，性能高于synchronized</p>
<p>Java提供的非阻塞式容器:</p>
<ul>
<li>ConcurrentLinkedQueue &amp; ConcurrentLinkedDeque</li>
<li>ConcurrentSkipListMap &amp; ConcurrentSkipListSet</li>
</ul>
<p>CAS的方式有一个ABA的问题，就是当前值为A被另一个线程先修改为B再修改为A，当前线程CAS操作无法分辨当前值是否发生过变化。 ABA一般不是问题，如果确实有需要可以使用AtomicStampedReference， 在修改值的时候附加一个时间戳</p>
<h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><ul>
<li>线程安全， 可以被多个线程并发访问</li>
<li>迭代器不支持修改操作，但也不会抛出ConcurrentModificaitonException</li>
<li>以原子方式支持一些符合操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> <span class="comment">//不存在才添加, 添加返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addAllAbsent</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="comment">//批量添加C中的非重复元素，不存在才添加，返回实际添加个数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList内部是一个数组，但是这个数组以原子方式被整体更新的。 每次修改操作， 都会新建一个数组，复制原数组的内容到新数组， 在新数组上进行需要的更改，然后以原子方式设置内部的数组引用， 这就是写时复制。<br>所有的读操作，都是先拿到当前引用的数组，然后直接访问该数组， 读的过程中， 可能内部的数据已经被修改了，但不会影响读操作，读的依旧是原数组内容</p>
<p>读不需要锁， 可以并行， 读和写也可以并行，但不能多个线程同时写，同时写需要锁</p>
<p>CopyOnWriteArrayList性能很低， 不适用于数组很大且修改频繁的场景.</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>每一个线程都有个map, 对于每个ThreadLocal对象，调用其get/set实际上就是以ThreadLocal对象为key读写当前线程的map</p>
<h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>线程协作的场景:</p>
<ul>
<li>生产者/消费者协作模式</li>
<li>同时开始</li>
<li>等待结束 主从协作模式，主线程讲任务分解为若干任务，主线程再继续执行其他任务前需要等待这些子线程执行完毕</li>
<li>异步结果 主从协作模式中，主线程手动创建自线程的写法比较麻烦，常见的模式时将子线程的管理封装为异步调用，异步调用完马上返回，但返回的不是最终结果而是Future的对象，通过它可以在随后获取最终结果</li>
<li>集合点 每个线程负责一部分计算，在集合点等待其他线程完成，等到齐后，交换数据和计算结果在进行下一次的迭代。</li>
</ul>
<h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><p>线程协作的基本机制是wait/notify</p>
<p>wait() 也就是 wait(0)表示无限期等待， 在等待期间都可以被中断，如果被中断，会抛出InterruptedException.</p>
<p>wait原理:<br>每个对象都有一把锁和等待队列，一个线程在进入synchronized代码块时会尝试获取锁，如果获取不到会把当前线程加入等待队列中，其实，除了锁的等待队列，每个对象还有另一个等待队列，表示条件队列，该队列用于线程的协作。 调用wait会把当前线程放到条件队列上并阻塞，表示当前线程执行不下去，需要等待一个条件，这个条件需要其他线程来更改，调用对象的notify, notify做的事情就是从条件队列里选一个线程，并将其从队列中移除并唤醒，notify和notifyAll的区别就是notifyAll会移除对象条件队列所有的线程并全部唤醒</p>
<p>调用wait/notify方法时， 当前线程没有持有对象锁，会抛出java.lang.IllegalMonitor-StateException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> fire = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   	 	<span class="meta">@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                	<span class="keyword">while</span>(!fire) &#123;</span><br><span class="line">                    	wait();</span><br><span class="line">                	&#125;</span><br><span class="line">            	&#125;</span><br><span class="line">            	System.out.println(<span class="string">"fired"</span>);</span><br><span class="line">        	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	<span class="keyword">this</span>.fire = <span class="keyword">true</span>;</span><br><span class="line">        	notify();</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        	WaitThread waitThread = <span class="keyword">new</span> WaitThread();</span><br><span class="line">        	waitThread.start();</span><br><span class="line">        	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        	System.out.println(<span class="string">"fire"</span>);</span><br><span class="line">        	waitThread.fire();</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Question: wait在synchronized保护中， 第一个线程在wait时，另一个线程怎么能调用到同在synchronized保护的notify方法呢?<br>Answer:</p>
<p>wait的具体过程是 :</p>
<ol>
<li>把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为WAITING或TIMED_WAITING</li>
<li>等待时间到或者被其他线程调用notify/notifyAll从条件队列中移除，这时要重新竞争对象锁<ul>
<li>如果能够获得锁，线程状态变为RUNNABLE, 并从wait调用中返回</li>
<li>否则，该线程加入对象锁的等待队列，线程状态变为BLOCKED, 只有获取锁后才会从wait调用返回</li>
</ul>
</li>
</ol>
<p>调用notify会把条件队列中等待的线程唤醒并从队列中移除，但他不会释放对象锁，也就是说，只有在包含notify的synchronized代码块执行完后，等待的线程才会从wait调用中返回</p>
<p>wait/notify它们被不同的线程调用，但共享相同的锁和条件等待队列（相同对象的synchronized代码块里),它们围绕一个共享的条件变量进行协作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;E&gt; queue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBlockingQueue</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">        queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;(limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == limit) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.add(e);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        E e = queue.poll();</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局限性, 只能有一个条件等待队列。</p>
<p>Java提供了专门的阻塞队列实现</p>
<ul>
<li>接口BlockingQueue和BlockingDequeue</li>
<li>基于数组的实现类ArrayBlockingQueue</li>
<li>基于链表的实现类LinkedBlockingQueue 和 LinkedBlockingDeque</li>
<li>基于堆的实现类PriorityBlockingQueue</li>
</ul>
<p>实际上join就是调用了wait实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isAlive()) &#123;</span><br><span class="line">	wait(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要线程是活着的，join就一直等待，当线程运行结束后，Java系统调用notifyAll来通知</p>
<h3 id="显示条件"><a href="#显示条件" class="headerlink" title="显示条件"></a>显示条件</h3><p>锁用于解决竞态条件问题，条件是线程间的协作机制。 显示锁与synchronized相对应， 显示条件与wait/notify相对应。 wait/notify与synchronized配合使用，显示条件与显示锁配合使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Lock接口定义创建条件方法</span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>; <span class="comment">//其他均响应中断，此方法不响应中断</span></span><br><span class="line">	<span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// await与wait对应, 调用await方法前需要先获取锁, 没有的话会抛异常IllegalMonitorStateException, await进入等待队列后会释放锁，释放CPU, 当其他线程将它唤醒后，或者等待超时后，或者发生中断异常后，它都需要重新获取锁，获取锁之后，才会从await方法中退出</span></span><br><span class="line"><span class="comment">// signal对于notify</span></span><br></pre></td></tr></table></figure>

<p>ReentrantLock Condition的实现原理 // TODO….</p>
<h3 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h3><p>Java中，停止一个线程的主要机制是中断，中断并不是强迫终止一个线程，它是一种协作机制，是给线程传递一个取消信号，但是由线程来决定如何以及何时退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>每一个线程都有一个标志位, 表示该线程是否被中断了.</p>
<ol>
<li>isInterrupted 返回对应线程的中断标志位是否为true</li>
<li>interrupted 返回当前线程的中断标志位是否为true, 并且 清空中断标志位</li>
<li>interrupt 表示中断对应的线程</li>
</ol>
<p>中断对线程的意义与线程的状态和正在进行的IO操作有关。这里我们主要考虑线程的状态</p>
<ul>
<li>RUNNABLE : 线程在运行或具备运行条件，只是在等待操作系统调度<br>  interrupt()只是会设置线程的中断标志位，没有其他作用，线程应该自身在合适位置检查中断标志位</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">run() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">		<span class="comment">// do something....</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>WAITING/TIMED_WAITING: 线程在等待某个条件或超时<br>  线程调用join/wait/sleep方法会进入WAITING/TIMED_WAITING状态，这些状态时，对线程调用interrupt()会使得该线程抛出InteruptedException, 需要注意的是， 抛出异常后，中断标志位会被清空而不是被设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">	run() &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1999</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">			System.out.println(isInterrupted()) <span class="comment">//...返回false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BLOCKED 线程在等待锁，试图进入同步块 </p>
<p>  线程在等待锁，对线程对象调用interrupted()只是会设置线程的中断标志位，线程依然会处于BLOCKED状态</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">INterruptSynchronizedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"exit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            A a = <span class="keyword">new</span> A();</span><br><span class="line">            a.start();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            a.interrupt();</span><br><span class="line">            a.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里线程A进入锁等待队列，随后test调用a的interrupted并不会结束a, 在使用synchronized关键字获取锁的过程中不响应中断请求，这也是synchronized的局限性</p>
<ul>
<li><p>NEW/TERMINATED 线程还未启动或已结束</p>
<p>  interrupted()对他没有任何影响，中断标志位也不会设置</p>
</li>
</ul>
<h3 id="协作工具类"><a href="#协作工具类" class="headerlink" title="协作工具类"></a>协作工具类</h3><ul>
<li>ReentrantReadWriteLock 在读多写少的场景里使用ReentrantReadWriteLock替代ReentrantLock提高性能</li>
<li>Semaphore 限制对资源的并发访问数</li>
<li>CountDownLatch 实现不同角色线程间的同步</li>
<li>CyclicBarrier 实现同一角色线程间的协调一致</li>
</ul>
<h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>// TODO…<br>无锁非阻塞并发队列: ConcurrentLinkedQueue &amp; ConcurrentLinkedDequeue<br>普通阻塞队列: 基于数组的ArrayBlockingQueue, 基于链表的LinkedBlockingQueue, LinkedBlockingDequeue<br>优先级阻塞队列: PriorityBlockingQueue<br>延时阻塞队列: DelayQueue<br>其他阻塞队列: SynchronousQueue &amp; LinkedTransferQueue</p>
<h2 id="并发容器类"><a href="#并发容器类" class="headerlink" title="并发容器类"></a>并发容器类</h2><h3 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h3><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap是HashMap的并发版本</p>
<ul>
<li>并发安全</li>
<li>支持一些原子复合操作</li>
<li>支持高并发， 读操作完全并行， 写操作一定程度上的并行</li>
<li>弱一致性</li>
</ul>
<p>Hashmap不是并发安全， 在并发更新的情况下可能会出现死循环，占满CPU<br>-&gt; Java7 HashMap死循环 TODO<br>-&gt; Java8 优化后减少了死循环的可能，但是扩容的时候仍然会死循环 TODO</p>
<p>-&gt; ConcurrentHashMap原理 TODO</p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>HashMap/HashSet基于哈希，不能对元素排序，对应的可排序的容器为TreeMap/TreeSet, 其对应的并发版本为 ConcurrentSkipListMap, ConcurrentSkipListSet<br>TreeSet是基于TreeMap实现的, ConcurrentSkipListSet也是基于ConcurrentSkipListMap实现.<br>ConcurrentSkipListMap是基于SkipList实现.<br>-&gt; 原理 TODO</p>
<h2 id="任务执行服务"><a href="#任务执行服务" class="headerlink" title="任务执行服务"></a>任务执行服务</h2><p>Thread即表示要执行的任务，又表示执行机制。Java并发包提供了一套框架，大大简化了执行异步任务所需的开发， 讲“任务的提交”和“任务的执行”分离。</p>
<ul>
<li>Runnalble 和 Callable: 表示要执行的异步任务 (Runnable没有返回结果，Callable有返回结果, Runnable不会抛出异常，Callable会)</li>
<li>用于执行异步任务的接口Executor, 以及有更多功能的子接口ExecutorService</li>
<li>表示异步结果的接口Future和实现类FutureTask</li>
<li>用于创建Executor和ExecutorService的工厂方法类Executors</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">executor</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">            &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">            &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">            Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过Future可以查询异步任务的状态，获取最终结果，取消任务等...</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">            <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// get()用于返回异步任务的结果，如果还没有结果，会阻塞. 可以指等待时间，超时会抛TimeoutException</span></span><br><span class="line">            <span class="comment">// cancel()用于取消异步任务, 如果任务已完成或者已取消，或不能取消，cancel返回false, 否则为 true</span></span><br><span class="line">            <span class="comment">// 如果任务还未开始，cancel后则不再运行, 如果已经运行，则不一定能取消，参数mayInterruptIfRunning表示如果任务正在执行，是否调用interrupt()中断线程, false不会</span></span><br><span class="line">            <span class="comment">// idDone表示任务是否结束，不管什么原因的结束都是true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// get有三种结果</span></span><br><span class="line">            <span class="comment">// 1. 正常完成，返回执行结果，如果是Runnable或者且没提供结果，返回null</span></span><br><span class="line">            <span class="comment">// 2. 任务执行抛出异常, get会讲异常包装为ExecutionException重新抛出, 通过getCause方法获取原异常</span></span><br><span class="line">            <span class="comment">// 3. 任务被取消, get会抛出异常InterruptedException</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>; <span class="comment">// 不再接受新任务，已提交的任务会继续执行，即使任务还未开始执行</span></span><br><span class="line">            <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>; <span class="comment">// 不仅不接受新任务， 而且终止已经提交但没执行的任务，对于正在执行的，会调用线程interrupt()来尝试中断， 返回已提交但没执行的任务列表</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>; <span class="comment">//调用shutdown或shutdownNow不代表所有任务都结束了，但是isShutdown会返回true</span></span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="comment">// invokeAll等待所有任务完成</span></span></span><br><span class="line"><span class="function">            <span class="comment">// invokeAny 只要有一个任务在限时内返回，就会返回该任务结果, 其他任务会被取消</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">            &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">            &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">            &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">            &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">### ThreadPoolExecutor ###</span><br><span class="line">```java</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, //核心线程个数</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize, //最大线程个数</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime, //空闲线程存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,//空闲线程存活时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,   //用于对创建的线程的一些配置</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> <span class="comment">// 表示任务拒绝策略</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    新任务到来时，如果当前线程个数小于corePoolSize， 就会创建一个新线程来执行该任务, 即使其他线程现在为空，也会创建新线程。 </span></span><br><span class="line"><span class="function">    如果线程个数&gt;</span>= corePoolSize, 就不会立即创建线程，而是先尝试排队（不是阻塞等待入队), 如果入队不了，就创建线程直到达到maximumPoolSize</span><br><span class="line"></span><br><span class="line">    BlockingQueue:</span><br><span class="line">    <span class="number">1</span>. LinkedBlockingQueue: 基于链表的阻塞队列，可以指定最大长度，默认无界</span><br><span class="line">    <span class="number">2</span>. ArrayBlockingQueue: 基于数组的有界阻塞队列</span><br><span class="line">    <span class="number">3</span>. PriorityBlockingQueue 基于堆的无界阻塞优先级队列</span><br><span class="line">    <span class="number">4</span>. SynchronousQueue: 没有实际存储空间的通不阻塞队列</span><br><span class="line"></span><br><span class="line">    任务拒绝策略:</span><br><span class="line">    <span class="number">1</span>. ThreadPoolExecutor.AbortPolicy 默认方式，抛出异常</span><br><span class="line">    <span class="number">2</span>. ThreadPoolExecutor.DiscardPolicy  静默处理，忽略新任务，不抛异常不执行</span><br><span class="line">    <span class="number">3</span>. ThreadPoolExecutor.DiscardOldestPolicy 等待时间最长的任务扔掉</span><br><span class="line">    <span class="number">4</span>. ThreadPoolExecutor.CallerRunsPolicy 将任务提交者线程中执行任务，而不是交给线程池中的线程执行</span><br></pre></td></tr></table></figure>

<h3 id="工厂类Executors"><a href="#工厂类Executors" class="headerlink" title="工厂类Executors"></a>工厂类Executors</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">其中newSingleThreadExecutor相当于</span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">newFixedThreadPool</span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())</span><br><span class="line"></span><br><span class="line">newCachedThreadPool</span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;())</span><br><span class="line">当新的任务来时，如果正好有空闲线程在等待任务，则其中一个空闲线程接受该任务，否则总是创建一个新线程， 对于空闲线程，如果<span class="number">60</span>s内没有接受新任务就中止</span><br></pre></td></tr></table></figure>

<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><h4 id="Timer-amp-TimerTask"><a href="#Timer-amp-TimerTask" class="headerlink" title="Timer &amp; TimerTask"></a>Timer &amp; TimerTask</h4><p>Tips: 固定延时fixed-delay 与固定频率 fixed-rate.<br>固定延时，是基于上次任务的实际执行时间来计算<br>固定频率会尽力补够运算次数</p>
<p>一个 Timer只有一个Timer线程， 在执行任何一个任务的run方法时，一旦run抛出异常，Timer线程就会退出，从而所有的任务都会被取消</p>
<h4 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h4><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul>
<li>Java7引入的Fork&amp;Join</li>
<li>Java8并行流</li>
<li>CompletionService</li>
<li>Java8引入的CompletableFuture</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ScorpioNeal</p>
              <p class="site-description motion-element" itemprop="description">体系(点 - 线 - 面)</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ScorpioNeal</span>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>



        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Bp6gNEmnfgAF2Ci7moO9v4Rm-gzGzoHsz',
        appKey: 'xNstrbz0DRkVzIMvuDNrkAOh',
        placeholder: '要不要说点啥',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="/js/src/dynamic_bg.js"></script>
  <script type="text/javascript" src="/js/src/love-click.js"></script>
</body>
</html>
